# === Unstaged changes ===
diff --git a/src/pclink/api_server/api.py b/src/pclink/api_server/api.py
index 36bab47..c92f644 100644
--- a/src/pclink/api_server/api.py
+++ b/src/pclink/api_server/api.py
@@ -596,6 +596,11 @@ def create_api_app(api_key: str, controller_instance, connected_devices: Dict, a
 async def broadcast_updates_task(manager: ConnectionManager, state: Any, network_monitor: NetworkMonitor):
     while True:
         try:
+            # Optimization: Skip expensive polling when no clients are connected
+            if not manager.active_connections:
+                await asyncio.sleep(5)  # Longer sleep when idle
+                continue
+            
             system_data = await get_system_info_data(network_monitor)
             media_data = await get_media_info_data()
             system_data["allow_insecure_shell"] = state.allow_insecure_shell
diff --git a/src/pclink/api_server/services.py b/src/pclink/api_server/services.py
index 07562bc..dc5b77a 100644
--- a/src/pclink/api_server/services.py
+++ b/src/pclink/api_server/services.py
@@ -38,6 +38,10 @@ SUBPROCESS_FLAGS = 0
 if sys.platform == "win32":
     SUBPROCESS_FLAGS = subprocess.CREATE_NO_WINDOW
 
+# Media info cache to reduce subprocess spawning
+_media_info_cache = {"data": None, "timestamp": 0}
+_MEDIA_CACHE_TTL = 2  # seconds
+
 
 async def run_subprocess(cmd: list[str]) -> str:
     """
@@ -272,18 +276,33 @@ class NetworkMonitor:
 async def get_media_info_data() -> Dict[str, str]:
     """
     Retrieves media playback information based on the operating system.
+    Uses caching to reduce expensive subprocess spawning and SDK calls.
 
     Returns:
         A dictionary containing media playback details.
     """
+    current_time = time.time()
+    
+    # Return cached data if still valid
+    if (_media_info_cache["data"] is not None and 
+        current_time - _media_info_cache["timestamp"] < _MEDIA_CACHE_TTL):
+        return _media_info_cache["data"]
+    
+    # Fetch new data
     if sys.platform == "win32":
-        return await _get_media_info_win32()
-    if sys.platform == "darwin":
-        return await _get_media_info_darwin()
-    if sys.platform.startswith("linux"):
-        return await _get_media_info_linux()
-
-    return DEFAULT_MEDIA_INFO
+        data = await _get_media_info_win32()
+    elif sys.platform == "darwin":
+        data = await _get_media_info_darwin()
+    elif sys.platform.startswith("linux"):
+        data = await _get_media_info_linux()
+    else:
+        data = DEFAULT_MEDIA_INFO
+    
+    # Update cache
+    _media_info_cache["data"] = data
+    _media_info_cache["timestamp"] = current_time
+    
+    return data
 
 
 def _get_sync_system_info(network_monitor: NetworkMonitor) -> Dict:
diff --git a/src/pclink/api_server/terminal.py b/src/pclink/api_server/terminal.py
index 93ffccc..dc4c47e 100644
--- a/src/pclink/api_server/terminal.py
+++ b/src/pclink/api_server/terminal.py
@@ -126,7 +126,7 @@ async def handle_windows_terminal(websocket: WebSocket, shell_type: str = "cmd")
                             await websocket.send_bytes(data)
                         else:
                             # Short sleep if no data is immediately available to prevent tight looping.
-                            await asyncio.sleep(0.01)
+                            await asyncio.sleep(0.05)  # Optimized: 20 iterations/sec instead of 100
                     except Exception as e:
                         log.error(f"Error reading subprocess output: {e}")
                         break

# === Staged changes ===
